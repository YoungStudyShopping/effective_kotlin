## 아이템 16: 프로퍼티는 동작이 아니라 상태를 나타내야 한다

- 프로퍼티는 사용자 정의 세터와 게터
- field 라는 식별지를 확인할 수 있습니다. 
	- 이는 프로퍼티의 데이터 를 저장해 두는 백킹 필드 (backingfield) 에 대한 레퍼런스입니다.
- `val` 을 사용해서 읽기 전용 프로퍼티를 만들 때는 field 가 만들어지지 않습니다.
-  `var` 을 사용해서 만든 읽고 쓸 수 있는 프로퍼티는 게터와 세터를 정의할 수 있습니다. 
	- 이러한 프로퍼티를 **파생 프로퍼티 (derived property)** 라고 부르며, 자주 사용됩니다.
-  코틀린의 모든 프로퍼티는 디폴트로 캡슐화되어 있습니다.
	- (p.93 예시) 코틀린은 데이터를 millis라는 별도의 프로퍼티로 옮기고, 이를 활용해서 date 프로퍼티에 데이터룰 저장하지 않고, 랩(wrap)/언랩(unwrap)하도록 코드를 변경하기만 하면 됩니다.
- 프로퍼티는 필드가 필요 없습니다. 오히려 프로퍼티는 개념적으로 접근자(`val` 의 경우 게터, `var` 의 경우 게터와 세터)를 나타냅니다. 
	- 따라서 코틀린은 인터페이스에도 프로퍼티를 정의할 수 있는 것입니다.
	- 따라서 다음과 같이 오버라이드할 수 있습니다. (p.93)
- 프로퍼티는 본질으로 함수이므로, 확장 프로퍼티를 만들 수도 있습니다.
- 프로퍼티는 필드가 아니라 접근자를 나타냅니다.
	- 이처럼 프로퍼티를 함수 대신 사용할 수도 있지만, 그렇다고 완전히 대체해서 시용하는 것은 좋지 않습니다.
	- 하지만 관습적으로 이런 게터에 그런 계산량이 필요하다고 예상하지는 않습니다. 따라서 이러한 처리는 프로퍼티가 아니라 함수로 구현해야합니다.
- 원칙적으로 프로퍼티는 상태를 나타내거나 설정하기 위한 목적으로만 사용하는 것이 좋고, 다른 로직 등을 포함하지 않아야 합니다. 
- 어떤 것을 프로퍼티로 해야하는지? 
	- "이 프로퍼티를 함수로 정의할 경우, 집두사로 get 또는 set을 붙일 것인가?" 
	- 만약 아니라면, 이를 프로퍼티로 만드는 것은 좋지 않습니다.
- 프로퍼티 대신 함수를 사용하는게 좋은 경우
 - 연산 비용이 높거나, 복잡도가 O(1) 보다 큰 경우
 - 비즈니스 로직(애플리케이션의 동작)을 포함하는 경우
 - 결정적이지 않은 경우
 - 변환의 경우
 - 게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우
- 반대로 상태를 추출/설정할 때는 프로퍼티를 사용해야 합니다.
- 많은 사람은 경험적으로 프로퍼티는 상태 집합을 나타내고, 함수는 행동을 나타낸다고 생각합니다.

