# 아이템 45 -  불필요한 객체 생성을 피하라
- 객체 생성은 언제나 비용
- 불필요한 객체 생성을 피하는 것이 최적화의 관 점에서 좋음
- JVM에서는 하나의 가상 머신에서 동일한 문자열을 처리하는 코드가 여러 개 있다면, 기존의 문자열을 재사용
- Integer와 Long처럼 박스화한 기본 자료형도 작은 경우에는 재사용 (기본적으로 Int는 - 128~127 범위를 캐시)
- nullable 타입은 int 자료형 대신 Integer 자료형을 사용하게 강제

## 객체 생성 비용은 항상 클까?
- 어떤 객체를 랩(wrap)하면, 크게 세 가지 비용이 발생
    - 객체는 더 많은 용량을 차지
        - 64비트 JDK에서 객체는 8바이트의 배수만큼 공간을 차지
        - 앞부분 12바이트는 헤더로서 반드시 있어 야 하므로, 최소 크기는 16바이트
        - 32비트 JVM에서는 8바이트
        - -Xmx=32G 까지는 32비트 플랫폼과 64비트 플랫폼 모두 4바이트
        - 64비트 플랫폼에서 32G(-Xmx32G)부터는 8바이트
        - 정수처럼 작은 것들을 많이 사용하면 그 비용의 차이가 더 커짐
        - 기본 자료형 int는 4바이트지만, 오늘날 널리 사용되고 있는 64비트 JDK에 랩(wrap)되어 있는 Integer는 16바이트
        - 이에 대한 레퍼 런스로 인해 8바이트가 더 필요합 니다 따라서 5배 이상의 공간을 차지
    - 요소가 캡슐화되어 있다면, 접근에 추가적인 함수 호출이 필요
        - 수많은 객체를 처리한다면, 이 비용도 굉장히 커짐
    - 객체는 생성되어야 함
        - 객체는 생성되고, 메모리 영역에 할당
        - 레퍼런스를 만드는 둥의 작업이 필요
- 모이면 굉장히 큰 비용
- 객체를 제거함으로써 이런 세 가지 비용을 모두 피할 수 있음

## 객체 선언
- 매 순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 객체 선언을 시용하는 것 (싱글톤)
- Nothing은 모든 타입의 서브타임
    - 따라서 LinkedList<Nothing>은 리스트가 covariant이라면 (out 한정자), 모든 Linkedlist의 서브타입이 됨
- 이러한 트릭은 immutable sealed 클래스를 정의할 때 자주 사용됨
- mutable 객체에 사용하면 공유 상태 관리와 관련된 버그를 검출하기 어려울 수 있으므로 좋지 않음
- mutable 객체는 캐시하지 않는다는 규칙을 지키는 것이 좋음
- 객체 선언 이의에도 객체 룰 재사용하는 다양한 방법이 있음

## 캐시를 활용하는 팩토리 함수
- 일반적으로 객체는 생성자를 사용
- 팩토리 메서드를 사용해서 만드는 경우도 있음
- 팩토리 함수는 캐시(cache)를 가질 수 있음
- 그래서 팩토리 함수는 항상 같온 객체를 리턴하게 만들 수도 있음
- 실제로 stdlib의 emptylist는 이를 활용해서 구현됨
- parameterized 팩토리 메서드도 캐싱을 활용할 수 있음
- 모든 순수 함수는 캐싱을 활용할 수 있음
    - 이를 메모이제이션(memoiza­ tion)이라 함
- 단점으로 캐시를 위한 Map을 저장해야 하므로, 더 많은 메모리를 사용함
    - 만약 메모리 문제로 크래시가 생긴다면 메모리를 해제
- 메모리가 필요할 때 가비지 컬렉터 (Garbage Collector, GC) 가 자동으로 메모리를 해제해 주는 SoftReference를 사용하면 더 좋음
    - WeakReference와 혼동하지 말 것
    - WeakReference와 SoftReference의 차이를 간단하게 정리하면 아래와 같음
        - WeakReference는 가비지 컬렉터가 값을 정리(clean)하는 것을 막지 않음
            - 따라서 다론 레퍼런스(변수)가 이를사용하지 않으면 곧바로 제거됨
        - SoftReferenc는 가비지 컬렉터가 값을 정리할 수도 있고, 정리하지 않을 수도 있음
            - 일반적인 JVM구현의 경우, 메모리가 부족해서 추가로 필요한 경우에만 정리
            - 따라서 캐시를 만들 때는 SoftReference를 사용하 는것이 좋음

## 무거운 객체를 외부 스코프로 보내기
- 성능을 위한 굉장히 유용한 트릭으로, 무거운 객체를 외부 스구프로 보내는 방법이 있음
- 컬렉션 처리에서 이루어지는 무거운 연산은 컬렉션 처리 함수 내부에서 외부로 빼는 것이 좋음
- 처음에 max 값을 찾아 두고, 이를 활용해서 수를 셈
- 반복 처리 중에 max 값을 한 번만 확인하므로 코드의 성능이 좋아짐
- 연산을 외부로 추출해서 값 계산을 추가로 하지 않게 만든다는 것이 당연
- 정규 표현식 패턴을 컴파일하는 과정은 꽤 복잡한 연산이라, 이처럼 함수를 호출할 때마다 계속해서 새로 만든다는 것은 성능적으로 문제
    - 정규 표현식을 톱레벨로 보내면, 이런 문제가 사라짐
- by lazy 를 써서 프로퍼티를 지연되게 만드는 것은 무거운 클래스를 사용할 때 유용

## 지연 초기화
- 무거운 클래스를 만들 때는 지연되게 만드는 것이 좋을 때가 있음
- 내부에 있는 인스턴스들을 지연 초기화하면, A라는 객체를 생성하는 과정을 가볍게 할 수 있음
- 지연 초기화는 장점도 있지만 단점도 있음
    - 클래스가 무거운 객체를 가졌지만, 메서드의 호출은 빨라야 하는 경우
    - 일반적으로 백엔드 애플리케이션은 전체적인 실행 시간은 중요 하지 않은데, 이처럼 지연되게 만들면, 첫 번째 호출 때 웅답 시간이 굉장히 길 것
    - 그래서 백엔드 애플리케이션에서 좋지 않을수 있음
- 지연 초기화는 상황에 맞게 사용해야 함

## 기븐 자료형 사용하기
- 코틀린/ JVM 컴파일러는 내부적으로 최대한 이러한 기본 자료형을 사용
- 단, 다음과 같은 두 가지 상황에서는 기본 자료형을 랩(wrap)한 자료형 사용
    - nullable 타입을 연산할 때(기본 자료형은 null일 수 없으므로)
    - 타입을 제네릭으로 사용할 때
- 이를 알면, 랩한 자료형 대신 기본 자료형을 사용하게 코드를 최적화
    - 이러한 최적화는코 틀린/JVM, 일부 코틀린/Native 버전에서만 의미가 있으며, 코틀린/JS에서는 아무런 의미가 없음
    - 또한 숫자에 대한 작업이 여러번 반복될 때만 의미가 있음
- 굉장히 큰 컬렉션을 처리할 때 차이를 확인할 수 있음
- 기존의 코드에서 사용되던 자료형을 일괄 변경하면, 코드를 읽기 힘들어질 수 있음
- 코드와 라이브러리의 성능이 굉장히 중요한 부분에서만 이를 적용

## 정리
- '무거운 객체를 외부 스코프로 보내기'는 성농도 향상시켜 주고, 객체에 이름을 붙여서 함수 내부에서 사용하므로 함수를 더 쉽게 읽을 수 있게 해줌