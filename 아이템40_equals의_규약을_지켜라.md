
## 아이템 40: equals의 규약을 지켜라

- 코틀린의Any에는 다음과 같이 잘 설정된 규약들을 가진 메서드들이 있습니다.
  - equals
  - hashCode
  - toString
- 규약을 위반하면, 일부 객체 또는 기능이 제대로 동작하지 않을 수도 있습니다.

<br>

### 동등성

코틀린에는 두 가지 종류의 동동성이 있습니다.

- 구조적 동등성 (structural equality)
- 레퍼 런스적 동동성 (referential equality)

equals는 모든 클래스의 슈퍼클래스인 Any에 구현되어 있으므로, 모든 객체에서 사용할 수 있습니다. 다만 연산자를 사용해서 다른 타입의 두 객체를 비교
하는 것은 허용되지 않습니다.

<br>

### equals가 필요한 이유

Any 클래스에 구현되어 있는 equals 메서드는 디폴트로 ===처럼 두 인스턴스가 완전히 같은 객체인지를 비교합니다. 이는 모든 객체는 디폴트로 유일한 객체라는 것을 의미합니다.

> '"'.equals(l)은 가능하지만, " "
>
> == 1은 불가능합니다

<br>

동동성을 약간 다른 형태로 표현해야 하는 객체가 있습니다. 예를 들어 두 객체가 기본 생성자의 프로퍼티가 같다면, 같은 객체로 보는 형태가 있을 수 있습니다. data 한정지를| 붙여서 데이터 클래스로 정의하면, 자동으로 이와 같은 동동성으로 동작합니다.

데이터 클 래스의 동동성은 모든 프로퍼티가 아니라 일부 프로퍼티만 비교해야 할 때도 유용합니다.

기본 생성자에 선언되지 않은 것을 복사하지 않는 동작은 올바른 동작이라고 할 수 있습니다.

equals를 직접 구현해야 하는 경우를 정리해 보면, 다음과 같습니다.

- 기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우
- 일부 프로퍼티만으로 비교해야 하는 경우
- data 한정자를 붙이는 것을 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는경우

<br>

### equals의 규약

다음과 같은 요구 사항을 충족해야 한다.

- 반사적 (reflexive) 동작: x가 널(null)이 아닌 값이라면, x.equals(x)는 true를 리턴해야 한다.
- 대칭적(symmetric) 동작: x와 y가 널이 아닌 값이라면, x.equals(y)는 y.equals(x)와 같은 결과를 출력해야 한다.
- 연속적(transitive) 동작: x, y, z가 널이 아닌 값이고 x.equals(y)와 y.equals(z)가 true라면, x.equals(z)도 true여야 한다.
- 일관적(consistent) 동작: x와 y가 널이 아닌 값이라면, x.equals(y)는 (비교 에 사용되는 프로퍼티를 변경한 것이 아니라면) 여러 번 실행하더라도 항상같은 결과를 리턴해야 한다.
- 널과 관련된 동작: x가 널이 아닌 값이라면, x.equals(null)은 항상 false를 리턴해야 한다.

equals, toString, hashCode의 동작은 매우 빠를 거라 예측되므로, 빠르게 동작해야 합니다.

equals는 반사적 동작을 해야 합니다. 이는 x.equals(x)가 true라는 것을 의미합니다.

결과에 일관성이 없으면, 실행 결과가 제대로 된 것인지 아닌지 알 수 없으므 로 코드를 신뢰할 수 없습니다.

equals는 대칭적 동작을 해야 합니다. 이는 X == y와 y == x가 같아야 한다 는 의미입니다. 일반적으로 다른 타입과 동등성을 확인하려고 할 때, 이런 동작이 위반됩니다.

동등성을 구현할 때는 항상 대칭성을 고려해야 합니다.

<br>

### equals 구현하기

특별한 이유가 없는 이상, 직접 equals를 구현하는 것은 좋지 않습니다.

직접 구현해야 한다면, 반사적, 대칭적, 연속적, 일관적 동작을 하는지 꼭 확인하세요. 그리고 이러한 클래스는 fma~ 만드는 것이 좋습니 다 만약 상속을 한다면, 서브클래스에서 equals가 작동하는 방식을 변경하면 안 된다는 것을 기억하세요.

> 참고로 데이터 클래스는 언제나 final입니다.
<br>
