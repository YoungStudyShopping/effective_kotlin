> # 5장 객체 생성
> 코틀린은 자바와 굉장히 비슷하지만, 세부적인 부분에서 큰 차이가 있습니다. 
> 어떤 차이가 있는지를 알아야 합니다.
> 
> 예) 코틀린은 정적 메서드를 사용할 수 없어 일반적으로 *톱레벨 함수* 와 *companion 객체 함수* 등을 대신 활용

## 아이템 33: 생성자 대신 팩토리 함수를 사용하라
- 클라이언트가 클래스의 인스턴스를 만들게 하는 가장 일반적인 방법은 `기본 생성자(primary constructor)` 를 사용하는 방법
- 다양한 **생성 패턴(creational pattern)**
	- 일반 적으로 이러한 생성 패턴은 객체를 생성자로 직접 생성하지 않고, 별도의 함수를 통해 생성합니다.
- 생성자의 역할을 대신 해 주는 함수를 **팩토리 함수** 라고 부릅니다.
	- 생성자와 다르게, 함수에 이름을 붙일 수 있습니다. (ex. `Arraylist.withSize(3)`)
		- 동일한 파라미터 타입을 갖는 생성자의 충돌을 줄일 수 있다는 장점
	- 생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있습니다.
		- 다른 객체를 생성할 때 사용 => 인터페이스 뒤에 실제 객체의 구현을 숨길 때 유용
		- 코틀린/JVM, 코틀린/JS, 코틀린/네이티브에 따라서 각 플랫폼의 빌트인 컬렉션으로 만들어짐 (코틀린 팀이 만든 핵심적인 최적화 중 하나)
	- 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없습니다. 
		- 함수를 사용해서 객체를 생성하면 싱글턴 패턴처럼 객체를 하나만 생성하게 강제하거나, 최적화를 위한 캐싱 메커니즘 사용 가능
	- 팩토리 함수는 아직 존재하지 않는 객체를 리턴할 수도 있습니다.
		- 어노테이션 처리를 기반으로 하는 라이브러리에서는 팩토리 함수를 많이 사용
		- 프로젝트를 빌드하지 않고도 앞으로 만들어질 객체를 시용하거나, 프록시를 통해 만들어지는 객체 사용 가능
	- 객체 외부에 팩토리 함수를 만들면, 그 가시성을 원하는 대로 제어할 수 있습니다 
	- 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 `reified` 로 만들 수있습니다.
	- 팩토리 함수는 생성자로 만들기 복잡한 객체도 만들어 낼 수 있습니다.
	- 팩토리 함수를 사용하면, 원하는 때에 생성지를 호출할 수 있습니다.
		- 생성자는 죽시 슈퍼클래스 또는 기본 생성자를 호출해야 함
- 팩토리 함수로 클래스를 생성할 때의 약간의 제한
	- 서브클래스 생성에는 슈퍼클래스의 생성자가 필요하기 때문에, 서브클래스를 만들어낼 수 없습니다.
	- 서브클래스에도 생성자를 만들어서 해결 가능 => 유연성, 클래스 독립성, nullable을 리턴하는 등의 다양한 특징을 갖습니다.
- 팩토리 함수는 **기본 생성자가 아닌 `추가적인 생성자(secondary constructor)`와 경쟁 관계** 입니다.
	- 일반적인 자바로 팩토리 패턴을 구현할 때는 생성자를 private으로 만들지만, 코틀린에서는 그렇게 하는 경우가 거의 없습니다. (item 34)
- 팩토리 함수 종류
	- companion 객체 팩토리 함수
	- 확장팩토리 함수
	- 톱레벨 팩토리 함수
	- 가짜 생성자
	- 팩토리 클래스의 메서드

#### Companion 객체 팩토리 함수
- 팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것입니다. 

```kotlin
...
class MyLinkedList<T>(
	val head: T,
	val tail: MyLinkedList<T>?

) {
	companion object {
		fun <T> of(vararg elements: T): MyLinkedList<T>? {
		/*...*/
		}
	}
}

// 사용
val list = Mylinkedlist.of(l, 2)
```
- 자바 개발자라면 이 코드가 정적 팩토리 함수(static factory function)와 같다는 것을 알 수 있을 것입니다.
	- C++와 같은 프로그래밍 언어에서는 이를 `이름을 가진 생성자(Named Constructor Idiom)`라고 부릅니다. 
	- 코틀린에서는 이러한 접근 방법을 인터페이스에도 구현할 수 있습니다.
- 많이 사용되는 이름 규칙
	- `from`
	- `of`
	- `valueOf`
	- `instance` 또는 `getInstance`
	- `createInstance` 또는 `newInstance`
	- `getType`
	- `newType`
- 경험이 없는 코틀린 개발자들은 companion 객체 멤버를 단순한 정적 멤버처 럼 다루는 경우가 많습니다. 하지만 companion 객체는 더 많은 기능을 갖고 있습니다.
	- 예를들어 companion 객체는 인터페이스를 구현할 수 있으며, 클래스를 상속받을 수도 있습니다.
	- 추상 companion 객체 팩토리는 값을 가질 수 있습니다. 따라서 캐싱을 구현하거나, 테스트를 위한 가짜 객체 생성(fake creation)을 할 수 있습니다.
- companion 객체를 제대로 사용하는 예 => 코틀린 팀 제품의 구현
	- 예시) 코틀린 코루틴 라이브러리. 거의 모든 코루틴 컨텍스트의 companion 객체가 컨텍스트를 구별할 목적으로 `CoroutineContext.Key` 인터페이스를 구현

#### 확장팩토리 함수
- companion 객체를 직접 수정할 수는 없고, 다른 파일에 함수를 만들어야 한다면 어떻게 할까요?
	- => **확장 함수**
- 팩토리 메서드를 만들어서, 외부 라이브러리를 확장 할 수 있습니다. 
	- 다만 companion 객체를 확장하려면, (적어도 비어 있는) 컴패니언 객체가 필요합니다.


#### 톱레벨 팩토리 함수
- 톱레벨 팩토리 함수
	- 대표적인 예 : `listOf` `setOf` `mapOf`
	- 라이브러리 사용 예시 : 안드로이드에서는 액티비티 (Activity) 를 시작하기 위해서, 인텐트(Intent)를 만드는 함수를 정의해서 사용합니다. 이를 코틀린으로 옮긴다면, getIntent()를 companion 객체로 다움과 같이 만들 수 있습니다. (p.214)
- 톱레벨 함수를 만들 때는 꼭 이름을 신중하게 생각해서 잘 지정해야합니다.


#### 가짜 생성자
- 코틀린의 생성자는 톱레벨 함수와 같은 형태로 사용됩니다.

```kotlin 
class A
val a = A()
```

- 톱레벨 함수처럼 참조될 수 있습니다 (생성자 레퍼런스는 함수 인터페이스로 구현합니다).

```kotlin 
val reference: ()->A = ::A
```

- 이러한 톱레벨 함수는 생성자처럼 보이고, 생성자처럼 작동합니다. 
	- 많은 개발자가 이 함수가 톱레벨 함수인지 잘 모릅니다. 그래서 이것울 `가짜생성자(fake constructor)` 라고 부르는 것입니다.
	- 예) List와 Mutablelist는 인터페이스. 따라서 생성자를 가질 수 없습니다. => 하지만 List를 생성자처럼 사용하는 코드 (`List (4) { "User$it" }` )
- 개발자가 진짜 생성자 대신에 가짜 생성자를 만드는 이유
	- 인터페이스를 위한 생성자를 만들고 싶을 때
	- reified 타입 아규먼트를 갖게 하고 싶을 때
- 이룰 제외하면, 가짜 생성자는 진짜 생성자처럼 동작해야 합니다. 
	- 생성자처럼 보여야 하며, 생성자와 같은 동작을 해야 합니다. 
	- 캐싱, nullable 타입 리턴, 서브클래스 리턴 동의 기능까지 포함해서 객체를 만들고 싶다면, companion 객
체 팩토리 메서드처럼 다른 이름을 가진 팩토리 함수를 사용하는 것이 좋습니다.
- 가짜 생성자를 선언하는 또 다른 방법
	- invoke 연산자를 갖는 companion 객체를 사용하면, 비슷한 결과를 얻을 수 있습니다.
	- 함수 이름을 활용해서도 연산자의 기능을 활용할 수 있음.
	- => 그러나 **추천하지 않는 방법** (item 12: '연산자 오버로드를 할 때는 의미에 맞게 하라' 에 위배)
		- invoke는 호출한다는 의미입니다. 따라서 객체 생성과 의미가 다릅니다.
		- 연산자를 오버로드하면, 원래 의미와 차이가 발생합니다.
		- 톱레벨 함수로 만드는 코드보다 훨씬 복잡합니다.
	- 리플렉션을 보면 지금 까지 살펴보았던 생성자, 가짜 생성자, invoke 함수의 복잡성을 확인할 수 있습니다.
- 기본 생성자를 만둘 수 없는 상황 또는 생성자가 제공하지 않는 기능(예: reified 타입 파라미터 등)으로 생성자를 만들어야 하는상황에만 가짜 생성지를 사용하는 것이 좋습니다.

#### 팩토리 클래스의 메서드

- 팩토리 클래스와 관련된 추상 팩토리, 프로토타입 등의 수많은 생성 패턴이 있습니다.
	- 점충적 생성자 패턴과 빌더 패턴온 코틀린에서는 의미가 없습니다,
- 팩토리 클래스는 클래스의 상태를 가질 수 있다는 특징 때문에 팩토리 함수보다 다양한 기능을 갖습니다.
- 팩토리 클래스는 프로퍼티를 가질 수 있습니다. 
	- 이를 활용하면 다양한 종류로 최적화하고, 다양한 기능을 도입할 수 있습니다. 
	- 예를 들어 캐싱을 활용하거나, 이전에 만든 객체를 복제해서 객체를 생성하는 방법으로 객체 생성 속도를 높일수 있습니다.

#### 정리
코틀린은 팩토리 함수를 만들 수 있는 다양한 방법들을 제공합니다.
객체를 생성할 때는 이런 특징을 잘 파악하고 사용해야 합니다.

팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것이며,
이 방식 온 자바 정적 팩토리 메서드 패턴과 굉장히 유사하고 코틀린은 자바의 스타일과 관습을 대부분 상속하므로 안전하고 익숙합니다.
